package org.openhab.binding.zwave.internal.protocol.security;

import java.security.GeneralSecurityException;
import java.security.KeyFactory;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.NoSuchProviderException;
import java.security.Provider;
import java.security.SecureRandom;
import java.security.Security;
import java.security.interfaces.ECPrivateKey;
import java.security.interfaces.ECPublicKey;
import java.security.spec.X509EncodedKeySpec;

import javax.crypto.KeyAgreement;
import javax.crypto.Mac;
import javax.crypto.SecretKey;

import org.bouncycastle.crypto.fips.FipsDRBG;
import org.eclipse.jdt.annotation.Nullable;

import com.sun.istack.internal.NotNull;

/**
 * A ZWaveSecurity2Crypto provider using on the the Java JCE interface on Java 8. This implementation uses the standard
 * JCE interface as much as possible. Abstract class as the Java 8 JCE API does not support all of the operations we
 * need
 *
 * @author Dave Badia
 *
 */
public abstract class ZWaveCryptoProviderJCEJava8 extends ZWaveCryptoProvider {
    protected static final String ALGORITHM_EC = "EC";
    /**
     * The name of the JCE provider to use. Will be passed to all JCE API calls to force this use of this provider.
     * Should be set to <b>null</b> if possible when possible to let the JRE decide which provider to use
     */
    protected final String jceProviderName;

    protected ZWaveCryptoProviderJCEJava8(@Nullable String jceProviderName)
            throws ZWaveCryptoException {
        if (jceProviderName != null && Security.getProvider(jceProviderName) == null) {
            throw new ZWaveCryptoException("JCE provider '" + jceProviderName + "' is not available");
        }
        this.jceProviderName = jceProviderName;
    }

    protected ZWaveCryptoProviderJCEJava8(@NotNull Provider jceProvider) throws ZWaveCryptoException {
        // Add it in the last position as:
        // 1. adding it elsewhere can cause issues with other crypto calls (SSL, etc)
        // 2. we will reference the jceProviderName in our calls to the API to force it's usage
        Security.addProvider(jceProvider);
        this.jceProviderName = jceProvider.getName();
    }

    /**
     * @inheritDoc
     */
    @Override
    protected SecureRandom buildPrngAccordingToZwaveSpec(SecureRandom entrophySource) {
        // @formatter:off
        /*
         * CC:009F.01.00.11.016 The PRNG MUST be implemented as an AES-128 CTR_DRBG as specified in [26]. The following
         * profile MUST be used:
         * No derivation function
         * No reseeding counter
         * Personalization string of 0x00 repeated 32 times
         * Output length = 16 bytes
         * security_strength is not used
         */
        // @formatter:on

        // TODO: call this instaeadreturn buildAesCounterModeDeterministicRandomNumberGenerator(entrophyBytes,
        // personalizationString, nonce, makePredictionResistant)
        // CC:009F.01.00.11.016
        FipsDRBG.Builder fipsDRBGBuilder = FipsDRBG.CTR_AES_128.fromEntropySource(entrophySource, true)
                .setPersonalizationString(new byte[32]).setEntropyBitsRequired(256);

        return fipsDRBGBuilder.build(entrophySource.generateSeed(16), true);
    }

    /**
     * {@inheritDoc}
     */
    @Override
    protected KeyPair generateECDHKeyPairAccordingToZwaveSpec(SecureRandom entrophySource)
            throws ZWaveCryptoException {
        // TODO: spec says we need to generate pub from private using EC 25519, figure out if JCE does it this way?
        try {
            KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(ALGORITHM_EC, jceProviderName);
            // TODO: use Algorithemparameters to pass our entrophySource
            keyPairGenerator.initialize(256);
            return keyPairGenerator.generateKeyPair();
        } catch (NoSuchAlgorithmException | NoSuchProviderException e) {
            throw new ZWaveCryptoException("Error during buildEntrophySource", e);
        }
    }

    /**
     *
     * CC:009F.01.00.11.017
     * <ul>
     * <b> SPEC_VIOLATION - not every device we run on has a hardward random input</b>
     * <li>The entropy_input [26] for instantiating the PRNG MUST be generated by a truly random source, e.g. white
     * radio noise. The PRNG MUST be hardware seeded.
     * </ul>
     * {@inheritDoc}
     */
    @Override
    protected SecureRandom buildEntrophySourceAccordingToZwaveSpec() throws ZWaveCryptoException {
        // SPEC_VIOLATION This is currently out of compliance with the zwave spec as it requires a hardware source of
        // entropy. See CC:009F.01.00.11.017
        try {
            return SecureRandom.getInstanceStrong();
        } catch (NoSuchAlgorithmException e) {
            throw new ZWaveCryptoException("Error during buildEntrophySource", e);
        }
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    protected byte[] executeDiffieHellmanKeyAgreement(ECPrivateKey ourPrivateKey, byte[] devicePublicKeyBytes,
            int nodeIdForLogging) throws ZWaveCryptoException {
        try {
            // Build public key object from bytes
            KeyFactory keyFactory = KeyFactory.getInstance(ALGORITHM_EC, jceProviderName);
            X509EncodedKeySpec x509KeySpec = new X509EncodedKeySpec(devicePublicKeyBytes);
            ECPublicKey devicePublicKey = (ECPublicKey) keyFactory.generatePublic(x509KeySpec);

            // Derive the shared secret using DH key agreement
            KeyAgreement keyAgreement = KeyAgreement.getInstance(ALGORITHM_EC, jceProviderName);
            keyAgreement.init(ourPrivateKey);
            keyAgreement.doPhase(devicePublicKey, true); // true = last phase
            byte[] sharedSecret = keyAgreement.generateSecret();
            return sharedSecret;
        } catch (RuntimeException | GeneralSecurityException e) {
            throw new ZWaveCryptoException(
                    "NODE {}: " + nodeIdForLogging + " SECURITY_2_ERR Error during ECDH key agreement", e);
        }
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    protected byte[] performAesCmac(SecretKey secretKey, byte[]... dataToMacArray)
            throws ZWaveCryptoException {
        try {
            Mac mac = Mac.getInstance("AESCMAC", jceProviderName);
            mac.init(secretKey);
            for (byte[] bytes : dataToMacArray) {
                mac.update(bytes);
            }
            return mac.doFinal();
        } catch (GeneralSecurityException e) {
            throw new ZWaveCryptoException("Error during AESCMAC encryption", e);
        }
    }

    /**
     * {@inheritDoc}
     *
     */
    @Override
    protected SecureRandom buildSpanNextNonceGenerator(byte[] mei, byte[] personalizationString)
            throws ZWaveCryptoException {
        /*
         * CC:009F.01.00.11.00F The CTR_DRBG MUST be instantiated using the following profile:
         * a. Entropy Input = MEI (obtained with CKDF-MEI_Expand)
         * b. Personalization_String = PersonalizationString
         * c. Output length = 16
         * d. No derivation function
         * e. No reseeding counter
         * f. No Security_strength
         */
        return buildAesCounterModeDeterministicRandomNumberGenerator(mei, personalizationString, null, false);
    }
}
